# Euler’s Method
import numpy as np
import matplotlib.pyplot as plt

f = lambda x,y: x+y
x0, y0 = 0, 1
h, n = 0.2, 10
x = np.linspace(x0, x0+n*h, n+1)
y = np.zeros(n+1)
y[0] = y0

for i in range(n):
    y[i+1] = y[i] + h*f(x[i], y[i])

plt.plot(x,y,'o-', label="Euler")
plt.xlabel('x'); plt.ylabel('y'); plt.legend(); plt.show()

# Picard Method
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0,2,11)
y = np.zeros(len(x))

# Picard Iteration: y1 = y0 + ∫f(x, y0)dx
y[0] = 1
for i in range(1,len(x)):
    y[i] = y[0] + sum((x[1:i+1]-x[:i])*((x[1:i+1]+y[:i])+(x[:i]+y[:i]))/2)  # Trapezoid approx

plt.plot(x,y,'o-', label="Picard")
plt.xlabel('x'); plt.ylabel('y'); plt.legend(); plt.show()

# Milne’s Method
import numpy as np
import matplotlib.pyplot as plt

f = lambda x,y: x+y
x0, y0 = 0, 1
h = 0.2
n = 10
x = np.linspace(x0, x0+n*h, n+1)
y = np.zeros(n+1)
y[0:4] = [1, 1.2, 1.44, 1.728]  # initial values from Euler or exact

for i in range(3,n):
    # Predictor
    yp = y[i-3] + 4*h/3*(2*f(x[i-2],y[i-2]) - f(x[i-1],y[i-1]) + 2*f(x[i],y[i]))
    # Corrector
    y[i+1] = y[i-1] + h/3*(f(x[i-1],y[i-1]) + 4*f(x[i],y[i]) + f(x[i+1],yp))

plt.plot(x[:len(y)],y,'o-', label="Milne")
plt.xlabel('x'); plt.ylabel('y'); plt.legend(); plt.show()
