# Newton-Raphson
import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return x**3 - 4*x - 9

def f_prime(x):
    return 3*x**2 - 4

def newton(x, tol=1e-5):
    if abs(f(x)) < tol:          # Base case: root found
        return x
    else:
        return newton(x - f(x)/f_prime(x), tol)  # Recursive call

root = newton(2.5)
print("Root =", root)

# Quick plot
x = np.linspace(1, 4, 100)
y = f(x)
plt.plot(x, y, 'b-', label='f(x)')
plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
plt.plot(root, 0, 'ro', markersize=8, label=f'Root = {root:.3f}')
plt.grid(True)
plt.legend()
plt.title('Newton-Raphson Method')
plt.show()
# Fixed Point Iteration
def g(x):
    return ((9 + 4*x)**(1/3))  # Example: x = g(x) => x^3 - 4x - 9 = 0

def fixed_point(x, tol=1e-5):
    if abs(x - g(x)) < tol:   # Base case: convergence
        return g(x)
    else:
        return fixed_point(g(x), tol)  # Recursive call

root = fixed_point(2.5)
print("Root =", root)

# Quick plot
x = np.linspace(1, 4, 100)
y = f(x)
plt.plot(x, y, 'g-', label='f(x)')
plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
plt.plot(root, 0, 'go', markersize=8, label=f'Root = {root:.3f}')
plt.grid(True)
plt.legend()
plt.title('Fixed Point Iteration')
plt.show()
# Bisection Method
import numpy as np
import matplotlib.pyplot as plt
def f(x):
    return x**3 - 4*x - 9

def Bisection(a, b, tol):
    # Check if root exists in interval
    if f(a) * f(b) > 0:
        print("No root in this interval.")
        return None

    c = (a + b) / 2

    if abs(f(c)) < tol:
        return c
    elif f(a) * f(c) < 0:
        return Bisection(a, c, tol)
    else:
        return Bisection(c, b, tol)

root = Bisection(2, 3, 0.0001)
print("Root =", root)
print(f"Bisection Root = {root:.6f}")

# Quick plot
x = np.linspace(1, 4, 100)
y = f(x)
plt.figure(figsize=(8, 5))
plt.plot(x, y, 'r-', label='f(x) = xÂ³ - 4x - 9')
plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
plt.axvspan(2, 3, alpha=0.2, color='red', label='Initial Interval [2,3]')
plt.plot(root, 0, 'ro', markersize=8, label=f'Root = {root:.3f}')
plt.grid(True, alpha=0.3)
plt.legend()
plt.title('Bisection Method')
plt.show()
# False Position Method
def false_position(a, b, tol=1e-5):
    # Check if root exists in interval
    if f(a) * f(b) > 0:
        print("No root in this interval.")
        return None
        
    c = (a*f(b) - b*f(a)) / (f(b) - f(a))  # Regula Falsi formula

    if abs(f(c)) < tol:        # Root found
        return c
    elif f(a)*f(c) < 0:        # Root in left side
        return false_position(a, c, tol)
    else:                      # Root in right side
        return false_position(c, b, tol)

root = false_position(2, 3)
print("Root =", root)

# Quick plot
x = np.linspace(1, 4, 100)
y = f(x)
plt.plot(x, y, 'm-', label='f(x)')
plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
plt.plot(root, 0, 'mo', markersize=8, label=f'Root = {root:.3f}')
plt.grid(True)
plt.legend()
plt.title('False Position Method')
plt.show()
